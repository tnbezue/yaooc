/*
		Copyright (C) 2016-2019  by Terry N Bezue

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <https://www.gnu.org/licenses/>.
*/

%include <yaooc/base_parser.yod>
%include <yaooc/exception.yod>

%header
#include <yaooc/string.h>
#include "components.h"


#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <fcntl.h>
#include <unistd.h>
#include <regex.h>
#include <yaooc/fstream.h>
#include <yaooc/regex.h>
#include <yaooc/garbage_bag.h>
#include <yaooc/algorithm.h>
#include <yaooc/thread.h>
%%

// Keyword tokens
#define CLASS(term) YAOOC_PARSER_TRY_RULE(this,M(this,chr,'%',&term) && M(this,str,"class",&term))
#define STRUCT(term) YAOOC_PARSER_TRY_RULE(this,M(this,chr,'%',&term) && M(this,str,"struct",&term))
#define UNION(term) YAOOC_PARSER_TRY_RULE(this,M(this,chr,'%',&term) &&  M(this,str,"union",&term))
#define MIXIN(term) YAOOC_PARSER_TRY_RULE(this,M(this,chr,'%',&term) &&  M(this,str,"mixin",&term))
#define TABLE(term) (M(this,str,"table",&term) && M(this,chr,':',&term))
#define INSTANCE(term) (M(this,str,"instance",&term) && M(this,chr,':',&term))
#define ADJUNCT(term) (M(this,str,"adjunct",&term) && M(this,chr,':',&term))
#define PRIVATE(term) (M(this,str,"private",&term) && M(this,chr,':',&term))
//#define STATIC(term) (M(this,str,"static",&term) && M(this,chr,'%',&term))
#define __CONST__(term) M(this,str,"const",&term)
#define OPERATOR(term) M(this,str,"operator",&term)
#define COMMA(term) M(this,chr,',',&term)
#define COLON(term) M(this,chr,':',&term)
#define SEMICOLON(term) M(this,chr,';',&term)
#define EQUAL(term) M(this,chr,'=',&term)
#define LPAREN(term) M(this,chr,'(',&term)
#define RPAREN(term) M(this,chr,')',&term)
#define LBRACE(term) M(this,chr,'{',&term)
#define RBRACE(term) M(this,chr,'}',&term)
#define LBRACKET(term) M(this,chr,'[',&term)
#define RBRACKET(term) M(this,chr,']',&term)
#define STAR(term) M(this,chr,'*',&term)

#define IS_DELETE(t) (strncmp(t.beg_,"delete",6)==0)
#define IS_DEFAULT(t) (strncmp(t.beg_,"default",7)==0)

char yaoocpp_parser_current_file[PATH_MAX]; // File specified on command line
char yaoocpp_parser_file_being_parsed[PATH_MAX]; // File being preprocessed -- could be and included file
bool yaoocpp_parser_is_top_level=false; // true when file being processed is the one specified on command line
yaooc_string_t yaoocpp_header_prefix = YAOOC_STRING_STATIC_DEFAULT_CTOR;
extern yaooc_string_t defines;
extern yaooc_string_vector_t include_directories;
//yaooc_string_t yaoocpp_definition_prefix = YAOOC_STRING_STATIC_DEFAULT_CTOR;

// For creating unique name for header and source sections
static int header_count=0;
static int source_count=0;

/*
  Prefix C preproccessor statements (lines that begin with #) with '%'
  Convert YAOOCPP entries (lines that begin with '%') to C preprocessor statements
*/
#define LINE_LENGTH 1024
static yaooc_string_t* preprocess(const char* file)
{
  gb_init();
  yaooc_string_t* contents=new(yaooc_string);
  regex_t re_cpp_line,re_yaoocpp_line,re_yaoocpp_include;
  if(regcomp(&re_cpp_line,"^\\s*#\\s*(.)",REG_EXTENDED) == 0 &&
        regcomp(&re_yaoocpp_line,"^\\s*%\\s*(if|define|endif)\\s+",REG_EXTENDED) == 0 &&
        regcomp(&re_yaoocpp_include,"^\\s*%\\s*(include)\\s+([<\"])([^\\.]+)\\.(yod|yoc)([>\"])",REG_EXTENDED) == 0) {
    regmatch_t ov[7];
    yaooc_ifstream_t input;
    newp(&input,yaooc_ifstream);
    M(&input,open,file,"r");
    if(M(&input,good)) {
      // Read file into memory.  Modifying certain directives so c preprocessor will ingore them
      yaooc_string_t output;
      newp(&output,yaooc_string);
      M(&output,append,"# 1 \"");
      M(&output,append,file);
      M(&output,append,"\"\n");
      char* line = gb_new_array(char,LINE_LENGTH);
      while(!M(&input,eof)) {
        *line=0;
        M(&input,getstr,line,LINE_LENGTH);
        if(regexec(&re_cpp_line,line,7,ov,0) == 0) {
          M(&output,append,"%X#");
          M(&output,append,line+ov[1].rm_so);
        } else if(regexec(&re_yaoocpp_line,line,7,ov,0) == 0) {
          M(&output,append,"#");
          M(&output,append,line+ov[1].rm_so);
        } else if(regexec(&re_yaoocpp_include,line,7,ov,0) == 0) {
          M(&output,append,"#");
          M(&output,append,line+ov[1].rm_so);
          M(&output,append,"%header\n%X#include ");
          M(&output,appendn,line+ov[2].rm_so,ov[2].rm_eo-ov[2].rm_so);
          M(&output,appendn,line+ov[3].rm_so,ov[3].rm_eo-ov[3].rm_so);
          M(&output,append,".h");
          M(&output,appendn,line+ov[5].rm_so,ov[5].rm_eo-ov[5].rm_so);
          M(&output,append,"\n%%\n");
        } else
          M(&output,append,line);
      }
      M(&input,close);

//      puts(M(&output,c_str));
      yaooc_string_t cpp_command;
      gb_newp(&cpp_command,yaooc_string);
      M(&cpp_command,set,"cpp  -nostdinc -fdirectives-only");
      if(M(&defines,size)>0) {
        M(&cpp_command,append," ");
        M(&cpp_command,append,M(&defines,c_str));
      }
      yaooc_string_vector_const_iterator id;
      CFOR_EACH(id,&include_directories) {
        M(&cpp_command,append," -I");
        M(&cpp_command,append,M(id,c_str));
      }
//      puts(M(&cpp_command,c_str));
//      puts(M(&output,c_str));
      yaooc_string_t* se=new(yaooc_string);
      int rc = command_pipe(M(&cpp_command,c_str),&output,contents,se);
      deletep(&cpp_command,yaooc_string);
      M(&output,set,M(contents,c_str));
      if(rc == 0) {
        rc = command_pipe("cpp -nostdinc -fpreprocessed",&output,contents,se);
//        printf("rc: %d\noutput:\n%s\n",rc,M(contents,c_str));
      } else {
        puts("Error in 1st pass of CPP");
        puts(M(se,c_str));
        exit(99);
      }
      deletep(&output,yaooc_string);
      delete(se);
      M(contents,gsub_,"\n%X#","\n#");
    } else {
      puts("File not found");
    }
    deletep(&input,yaooc_ifstream);
    regfree(&re_yaoocpp_line);
    regfree(&re_cpp_line);
    regfree(&re_yaoocpp_include);
  } else {
    printf("Failed compiling CPP line\n");
    exit(3);
  }
  gb_exit();
  return contents;
}

%class yaoocpp_parser : yaooc_base_parser {

    yaoocpp_parser()
    {
      yaooc_base_parser_default_ctor(this);
      newp(&this->sections_,yaoocpp_item_pointer_vector);
      newp(&this->mixins_,yaoocpp_item_pointer_vector);
    }

    ~yaoocpp_parser()
    {
      deletep(&this->sections_,yaoocpp_item_pointer_vector);
      deletep(&this->mixins_,yaoocpp_item_pointer_vector);
    }

  instance:
    yaoocpp_item_pointer_vector_t sections_;
    yaoocpp_item_pointer_vector_t mixins_;

  table:
    void parse_file(const char* fname)
    {
      strcpy(yaoocpp_parser_current_file,fname);
      yaooc_string_t* result = preprocess(fname);
//      puts(M(result,c_str));
      M(this,set_parse_string,M(result,c_str));
      yaooc_token_t r;
      M(this,whitespace,&r);
      yaoocpp_section_t* current_section;
      yaoocpp_mixin_t* mixin;
      while(true) {
        if(yaoocpp_parser_class_forward(this,&current_section)) {
          M(&this->sections_,push_back,make_dynamic_pointer(current_section));
          delete(current_section);
        } else if(yaoocpp_parser_class_definition(this,&current_section)) {
          M(&this->sections_,push_back,make_dynamic_pointer(current_section));
          delete(current_section);
        } else if(yaoocpp_parser_header_directory(this)) {
//          M(&this->sections_,push_back,(pointer)&current_section);
//          delete(current_section);
        } else if(yaoocpp_parser_header(this,(pointer)&current_section)) {
          M(&this->sections_,push_back,make_dynamic_pointer(current_section));
          delete(current_section);
        } else if(yaoocpp_parser_mixin(this,&mixin)) {
          M(&this->mixins_,push_back,make_dynamic_pointer(mixin));
          delete(mixin);
//        } else if(yaoocpp_parser_definition_directory(this)) {
//          M(&this->sections_,push_back,(pointer)&current_section);
        } else if(*this->current_pos_ != 0) {
          yaoocpp_parser_source(this,&current_section);
          M(&this->sections_,push_back,make_dynamic_pointer(current_section));
          delete(current_section);
        } else {
          break;
        }
      }
      delete(result);
    }

    bool whitespace(yaooc_token_t* r)
    {
      *r = yaooc_default_token(this);
      yaooc_token_t temp;
      bool rc=false;
      while(true) {
        rc = yaooc_base_parser_whitespace(this,&temp);
        if(!rc) {
          rc=yaoocpp_parser_line_directive(this);
          if(!rc)
            break;
        }
      }
      r->end_=yaooc_base_parser_current_pos(this);
      return r->beg_ != r->end_;
    }
  adjunct:
    bool line_directive()
    {
      RULE_START(this);
      if(*this->current_pos_ == '#') {
        this->current_pos_+=2;  // the "#" and the space following it
        yaooc_token_t temp;
        if(M(this,digits,&temp)) {
          this->line_no_=atoi(temp.beg_)-1;
          this->current_pos_++;
          if(*this->current_pos_ == '"') {  // Should be a double quoute - but check anyway
            this->current_pos_++;
            const char* pos=this->current_pos_;
            for(;*this->current_pos_!='"' && *this->current_pos_!=0;this->current_pos_++);
            if(*this->current_pos_ != 0) {
              strncpy(yaoocpp_parser_file_being_parsed,pos,this->current_pos_-pos);
              yaoocpp_parser_file_being_parsed[this->current_pos_-pos]=0;
              yaoocpp_parser_is_top_level=strcmp(yaoocpp_parser_current_file,yaoocpp_parser_file_being_parsed) == 0;
              for(;*this->current_pos_!='\n' && *this->current_pos_!=0;this->current_pos_++);
              yaooc_base_parser_whitespace(this,&temp);
              return RULE_SUCCESS(this);
            }
          }
        }
      }
      return RULE_FAIL(this);
    }

    bool header_directory()
    {
      RULE_START(this);
      yaooc_token_t temp,dirname;
      if(M(this,chr,'%',&temp)) {
        // Save line number.  If after next token, the line number has changed,
        // then only spaces follows directive -- an error
        int saved_line_no=this->line_no_;
        if(M(this,str,"header_directory",&temp)) {
          if(saved_line_no == this->line_no_) {
            if(M(this,double_quoted_string,&dirname) || M(this,bare_string,&dirname)) {
              M(&yaoocpp_header_prefix,setn,dirname.beg_,dirname.end_-dirname.beg_);
              M(&yaoocpp_header_prefix,rtrim_);
              return RULE_SUCCESS(this);
            }
          } else {
            printf("No directory specifed for header directory at line number %d\n",saved_line_no);
          }
        }
      }
      return RULE_FAIL(this);
    }

    bool header(yaoocpp_section_t** section)
    {
      RULE_START(this);
      yaooc_token_t temp;
      if(M(this,chr,'%',&temp) && M(this,str,"header",&temp)) {
        int saved_line_no = this->line_no_;
        const char* start_pos=yaooc_base_parser_current_pos(this);
        while(!M(this,str,"%%",&temp) && *this->current_pos_ != 0) {
          M(this,string_until_eol,&temp);
        }
        if(temp.end_ == NULL) {
          printf("Unterminated header declaration starting near %d\n",saved_line_no);
          exit(5);
        }
//        if(yaoocpp_parser_is_top_level) {
          yaoocpp_header_t* hs= new(yaoocpp_header);
          char name[16];
          sprintf(name,"header_%03d",header_count++);
          M(&hs->name_,set,name);
          M(&hs->content_,setn,start_pos,temp.beg_-start_pos);
          hs->defined_in_top_level_file_=true;
          *section = (yaoocpp_section_t*)hs;
//        }
        return RULE_SUCCESS(this);
      }
      return RULE_FAIL(this);
    }

    bool source(yaoocpp_section_t** section)
    {
      regex_t re;
//      yaooc_token_t t;
      if(regcomp(&re,"%\\s*(class|struct|union|header|mixin|header_directory)\\s+",REG_EXTENDED)==0) {
        regmatch_t ov[3];
        const char* ptr;
        if(regexec(&re,this->current_pos_,3,ov,0)==0) {
          ptr=this->current_pos_+ov[0].rm_so;
        } else {
          ptr=this->current_pos_+strlen(this->current_pos_);
        }
        yaoocpp_source_t* ss = new(yaoocpp_source);
        char name[16];
        sprintf(name,"source_%03d",source_count++);
        M(&ss->name_,set,name);
        size_t n = ptr-this->current_pos_;
        M(&ss->content_,setn,this->current_pos_,n);
        ss->defined_in_top_level_file_=true;
        *section = (yaoocpp_section_t*)ss;
        yaooc_base_parser_skip(this,n);
        regfree(&re);
      } else {
        printf("Regex compilation failed failed");
        exit(-1);
      }
      return true;
    }

    bool class_forward(yaoocpp_section_t** section)
    {
      RULE_START(this);
      yaooc_token_t t,name;
      if((CLASS(t) || STRUCT(t) || UNION(t)) && M(this,ident,&name) && SEMICOLON(t)) {
        yaoocpp_header_t* hs= new(yaoocpp_header);
        char hname[16];
        sprintf(hname,"header_%03d",header_count++);
        M(&hs->name_,set,hname);
        M(&hs->content_,set,"yaooc_class_forward(");
        M(&hs->content_,appendn,name.beg_,name.end_-name.beg_);
        M(&hs->content_,append,");\n");
        hs->defined_in_top_level_file_=true;
        *section = (yaoocpp_section_t*)hs;
        return RULE_SUCCESS(this);
      }
      return RULE_FAIL(this);
    }

    bool class_definition(yaoocpp_section_t** section)
    {
      yaooc_token_t temp;
      RULE_START(this);
      *section = NULL;
      bool is_struct = false;
      if(CLASS(temp))
        *section=(yaoocpp_section_t*)new(yaoocpp_class);
      else if(UNION(temp))
        *section=(yaoocpp_section_t*)new(yaoocpp_union);
      else if(STRUCT(temp)) {
        *section=(yaoocpp_section_t*)new(yaoocpp_struct);
        is_struct = true;
      }
      if(*section != NULL) {
        ((yaoocpp_struct_t*)*section)->defined_in_top_level_file_=yaoocpp_parser_is_top_level;
        yaooc_token_t class_name;
        M(this,ident,&class_name);
        M(&(*section)->name_,setn,class_name.beg_,class_name.end_-class_name.beg_);
        if(strncmp(class_name.beg_,"yaooc_object",class_name.end_-class_name.beg_) != 0) {

          char* parent_name=NULL;
          if(!yaoocpp_parser_get_parent_name(this,&parent_name) && !is_struct)
            parent_name=yaooc_strdup("yaooc_object");
          if(parent_name != NULL ) {
            if(!yaoocpp_parser_set_parent(this,parent_name,&((yaoocpp_struct_t*)*section)->parent_)) {
              printf("Parent class '%s' for '%.*s' not defined\n",parent_name,(int)(class_name.end_-class_name.beg_),class_name.beg_);
              exit(6);
            }
          if(is_struct)
            yaoocpp_struct_inherit(*section);
          else
            yaoocpp_class_inherit(*section);
          }
          if(parent_name != NULL)
            delete(parent_name);
        }
        if(LBRACE(temp)) {
          while(true) {
            if(!yaoocpp_parser_type_info(this,(yaoocpp_struct_t*)*section))
              if(!yaoocpp_parser_constructor(this,(yaoocpp_struct_t*)*section))
                break;
          }
          while(true) {
            if(TABLE(temp)) {
              if(is_struct) {
                printf("Table not allowed for struct %.*s",(int)(class_name.end_-class_name.beg_),class_name.beg_);
                exit(7);
              }
              yaoocpp_parser_sub_section(this,&((yaoocpp_class_t*)*section)->table_,true);
            } else if(INSTANCE(temp)) {
              yaoocpp_parser_sub_section(this,&((yaoocpp_struct_t*)*section)->instance_,false);
            } else if(ADJUNCT(temp)) {
              yaoocpp_parser_sub_section(this,&((yaoocpp_struct_t*)*section)->adjunct_,true);
            } else if(PRIVATE(temp)) {
              yaoocpp_parser_sub_section(this,&((yaoocpp_struct_t*)*section)->private_,true);
            } else
              break;
          }
        }
        if(RBRACE(temp) && SEMICOLON(temp)) {
          if(((yaoocpp_struct_t*)*section)->defined_in_top_level_file_) {
            M(((yaoocpp_struct_t*)*section),resolve_outstanding_components);
            M(*section,add_mixins,&this->mixins_);
          }
          return RULE_SUCCESS(this);
        }
        else {
          printf("Error processing %s near line number %d\n",yaoocpp_parser_file_being_parsed,this->line_no_);
          exit(7);
        }
      }
      return RULE_FAIL(this);
    }

    bool sub_section(yaoocpp_item_pointer_vector_t* list,bool include_value)
    {
      yaoocpp_variable_t* var;
      yaoocpp_method_t* method;
      while(true) {
        yaooc_dynamic_pointer_t* dp;
        if(yaoocpp_parser_variable(this,&var,include_value)) {
          dp = yaooc_find(yaooc_dynamic_pointer,M(list,cbegin),M(list,cend),make_dynamic_pointer(var));
          if(dp == M(list,cend)) {
            M(list,push_back,make_dynamic_pointer(var));
//            existing_var=M(list,begin);
          } else {
            yaoocpp_variable_t* existing_var=dp->ptr_;
            if(existing_var->generation_!=INHERITED) {

              printf("Duplicate variable specified on or before line number %d\n",this->line_no_);
              printf("X%sX X%sX\n",M(&existing_var->name_,c_str),M(&var->name_,c_str));
              exit(3);
            }
            assign_static(&existing_var->value_,&var->value_,yaooc_string);
            existing_var->generation_=OVERRIDDEN;
          }
          delete(var);
        } else if(yaoocpp_parser_method(this,&method)) {
          dp = yaooc_find(yaooc_dynamic_pointer,M(list,begin),M(list,end),make_dynamic_pointer(method));
          if(dp == M(list,cend))
            M(list,push_back,make_dynamic_pointer(method));
          else {
            yaoocpp_method_t* existing_method = dp->ptr_;
            if(existing_method->generation_!=INHERITED) {

              printf("Duplicate method specified on or before line number %d\n",this->line_no_);
              exit(3);
            }
            assign_static(existing_method,method,yaoocpp_method);
            existing_method->generation_=OVERRIDDEN;

          }
          delete(method);
        } else
          break;
      }
      return true;
    }

    bool variable(yaoocpp_variable_t** var,bool include_value)
    {
      RULE_START(this);
      yaooc_token_t t,val;
      yaoocpp_argument_t* arg;
      *var=NULL;
      if(yaoocpp_parser_argument(this,&arg)) {
        *var = new(yaoocpp_variable);
        assign_static(*var,arg,yaoocpp_argument);  // can do this because variable is decendent of argument
        delete(arg);
        int saved_line_no=this->line_no_;
        if(YAOOC_PARSER_TRY_RULE(this,EQUAL(t) && M(this,string_until_chrs,";",&val) && SEMICOLON(t))) {
          if(!include_value) {
            printf("Unexpected default value near line number %d\n",saved_line_no);
            exit(17);
          }
          M(&(*var)->value_,setn,val.beg_,val.end_-val.beg_);
          return RULE_SUCCESS(this);
        } else if(SEMICOLON(t)) {
          // A variable without a default value, set to zero
          M(&(*var)->value_,set,"0");
          return RULE_SUCCESS(this);
        }
      } else if(M(this,ident,&val) && SEMICOLON(t)) {  // Just a variable type
        *var=new(yaoocpp_variable);
        M(&(*var)->type_,setn,val.beg_,val.end_-val.beg_);
        return RULE_SUCCESS(this);
      }
      if(*var != NULL)
        delete(*var);
      return RULE_FAIL(this);
    }

    bool method(yaoocpp_method_t** method)
    {
      RULE_START(this);
      yaooc_token_t t,implementation;
      yaoocpp_argument_t* arg;
      if(yaoocpp_parser_argument(this,&arg) && LPAREN(t)) {
        *method = new(yaoocpp_method);
        M(&(*method)->type_,set,M(&arg->type_,c_str));
        M(&(*method)->name_,set,M(&arg->name_,c_str));
        delete(arg);
        yaoocpp_parser_arguments(this,&(*method)->arguments_);
        if(RPAREN(t)) {
          if(__CONST__(t))
            (*method)->is_const_=true;
          if(M(this,string_within_matching_chr,'{','}',&implementation)) {
            M((*method),set_implementation,implementation.beg_,implementation.end_-implementation.beg_);
            return RULE_SUCCESS(this);
          } else if (EQUAL(t) && (M(this,ident,&implementation) || M(this,str,"0",&implementation)) && SEMICOLON(t)) {
            M((*method),set_implemented_as,implementation.beg_,implementation.end_-implementation.beg_);
            return RULE_SUCCESS(this);
          } else {
            printf("Error processing implementation for method %s\n",M(&(*method)->name_,c_str));
          }
        }
      }
      return RULE_FAIL(this);
    }

    bool get_parent_name(char ** name)
    {
      yaooc_token_t temp;
      if(COLON(temp)) {
        if(!M(this,ident,&temp)) {
          printf("Expecting parent name after ':' near line %d",this->line_no_);
          exit(8);
        }
        *name=yaooc_token_raw_text(&temp);
        return true;
      }
      return false;
    }

    bool set_parent(const char*parent_name,const yaoocpp_struct_t** parent)
    {
      // Put class name in item to find in list
      yaoocpp_item_t parent_item;
      newp(&parent_item,yaoocpp_item);
      M(&parent_item.name_,set,parent_name);
      yaooc_dynamic_pointer_const_pointer dp=yaooc_find(yaooc_dynamic_pointer,M(&this->sections_,cbegin),
          M(&this->sections_,cend),make_dynamic_pointer(&parent_item));
      if(dp != M(&this->sections_,cend))
        *parent=(yaoocpp_struct_t*)dp->ptr_;
      else
        *parent=NULL;
      deletep(&parent_item,yaoocpp_item);
      return *parent != NULL;
    }

    bool type_info(yaoocpp_struct_t* section)
    {
      bool ret=true;
      if(!yaoocpp_parser_default_constructor(this,section,true))
        if(!yaoocpp_parser_destructor(this,section))
          if(!yaoocpp_parser_copy_constructor(this,section,true))
            if(!yaoocpp_parser_assignment(this,section))
              if(!yaoocpp_parser_rich_compare(this,section))
                if(!yaoocpp_parser_to_stream(this,section))
                  if(!yaoocpp_parser_from_stream(this,section))
                    if(!yaoocpp_parser_include(this,section))
                      ret=false;
      return ret;
    }

    bool constructor_initializers(yaoocpp_item_pointer_vector_t* list)
    {
      yaooc_token_t t,id,value;
      gb_init();
      do {
        int saved_line_no = this->line_no_;
        if(M(this,ident,&id)) {
          saved_line_no = this->line_no_;
          if(M(this,string_within_matching_chr,'(',')',&value)) {
            char* id_text=gb_save(yaooc_token_raw_text(&id));
            char* value_text=gb_save(yaooc_token_raw_text(&value));
            yaoocpp_constructor_initializer_t* temp=gb_new_ctor(yaoocpp_constructor_initializer,
                  yaoocpp_constructor_initializer_ctor_id_value,id_text,value_text);
            M(list,push_back,make_dynamic_pointer(temp));
          } else {
            printf("Error processing constructor initializers near line %d\n",saved_line_no);
            exit(9);
          }
        } else {
          printf("Error processing constructor initializers near line %d\n",saved_line_no);
          exit(10);
        }
      } while(COMMA(t));
      gb_exit();
      return true;  // Would have thrown error if not at least one or other parsing error
    }

    bool default_constructor(yaoocpp_struct_t* section,bool allow_initializers)
    {
      yaooc_token_t t,implementation;
      const char* class_name=M(&section->name_,c_str);
      RULE_START(this);
      bool has_initializers=false;
      if(M(this,str,class_name,&t) && LPAREN(t) && RPAREN(t)) {
        M(&section->default_ctor_.name_,set,class_name);
//        M(&section->default_ctor_.name_,append,"_default_ctor");
        if(COLON(t)) {
          has_initializers=true;
          yaoocpp_parser_constructor_initializers(this,&section->default_ctor_.initializers_);
        }
        if(has_initializers && !allow_initializers) {
          printf("Constructor initializers not allowed here.  Near line %d\n",this->line_no_);
          exit(77);
        }
        if(YAOOC_PARSER_TRY_RULE(this,M(this,string_within_matching_chr,'{','}',&implementation))) {
          // If not top level file, can skip the implementation code
          M(&section->default_ctor_,set_implementation,implementation.beg_,implementation.end_-implementation.beg_);
          return RULE_SUCCESS(this);
        } else if(EQUAL(t) && M(this,ident,&implementation) && SEMICOLON(t)) {
          if(has_initializers) {
            printf("Error processing default constructor for class %s\n"
                   "Cannot specify construction initializers and implementation method",class_name);
            exit(1);
          }
          if(IS_DELETE(implementation)) {
            section->default_ctor_.form_=DELETE;
          } else if(IS_DEFAULT(implementation)) {
            section->default_ctor_.form_=DEFAULT;
          } else {
            M(&section->default_ctor_,set_implemented_as,implementation.beg_,implementation.end_-implementation.beg_);
          }
          return RULE_SUCCESS(this);
        } else {
          printf("Error processing file %s at line number %d\n",yaoocpp_parser_file_being_parsed,this->line_no_);
          exit(1);
        }
      }
      return RULE_FAIL(this);
    }

    bool destructor(yaoocpp_struct_t* section)
    {
      yaooc_token_t t,implementation;
      const char* class_name=M(&section->name_,c_str);
      RULE_START(this);
      if(M(this,chr,'~',&t) && M(this,str,class_name,&t) && LPAREN(t) && RPAREN(t)) {
        M(&section->dtor_.name_,set,class_name);
//        M(&section->dtor_.name_,append,"_dtor");
        if(YAOOC_PARSER_TRY_RULE(this,M(this,string_within_matching_chr,'{','}',&implementation))) {
          // If not top level file, can skip the implementation code
          M(&section->dtor_,set_implementation,implementation.beg_,implementation.end_-implementation.beg_);
          return RULE_SUCCESS(this);
        } else if(EQUAL(t) && M(this,ident,&implementation) && SEMICOLON(t)) {
          // If not top level file, can skip the implementation code
          if(IS_DELETE(implementation)) {
            section->dtor_.form_=DELETE;
          } else if(IS_DEFAULT(implementation)) {
            section->dtor_.form_=DEFAULT;
          } else {
            M(&section->dtor_,set_implemented_as,implementation.beg_,implementation.end_-implementation.beg_);
          }
          return RULE_SUCCESS(this);
        } else {
          printf("Error processing file %s at line number %d\n",yaoocpp_parser_file_being_parsed,this->line_no_);
          exit(1);
        }
      }
      return RULE_FAIL(this);
    }

    bool copy_constructor(yaoocpp_struct_t* section,bool allow_initializers)
    {
      yaooc_token_t t,src_name,implementation;
      const char* class_name=M(&section->name_,c_str);
      RULE_START(this);
      bool has_initializers=false;
      if(M(this,str,class_name,&t) && LPAREN(t) && M(this,ident,&src_name) && RPAREN(t)) {
        M(&section->copy_ctor_.name_,set,class_name);
//        M(&section->copy_ctor_.name_,append,"_copy_ctor");
        M(&section->copy_ctor_,set_source_name,src_name.beg_,src_name.end_-src_name.beg_);
        if(COLON(t)) {
          has_initializers=true;
          yaoocpp_parser_constructor_initializers(this,&section->copy_ctor_.initializers_);
        }
        if(has_initializers && !allow_initializers) {
          printf("Constructor initializers not allowed here.  Near line %d\n",this->line_no_);
          exit(77);
        }
        if(YAOOC_PARSER_TRY_RULE(this,M(this,string_within_matching_chr,'{','}',&implementation))) {
          // If not top level file, can skip the implementation code
          M(&section->copy_ctor_,set_implementation,implementation.beg_,implementation.end_-implementation.beg_);
          return RULE_SUCCESS(this);
        } else if(EQUAL(t) && M(this,ident,&implementation) && SEMICOLON(t)) {
          if(has_initializers) {
            printf("Error processing copy constructor for class %s\n"
                   "Cannot specify construction initializers and implementation method",class_name);
            exit(1);
          }
          // If not top level file, can skip the implementation code
          if(IS_DELETE(implementation)) {
            section->copy_ctor_.form_=DELETE;
          } else if(IS_DEFAULT(implementation)) {
            section->copy_ctor_.form_=DEFAULT;
          } else {
            M(&section->copy_ctor_,set_implemented_as,implementation.beg_,implementation.end_-implementation.beg_);
          }
          return RULE_SUCCESS(this);
        } else {
          printf("Error processing file %s at line number %d\n",yaoocpp_parser_file_being_parsed,this->line_no_);
          exit(1);
        }
      }
      return RULE_FAIL(this);
    }

    bool assignment(yaoocpp_struct_t* section)
    {
      yaooc_token_t t,src_name,implementation;
      RULE_START(this);
      if(M(this,str,"operator",&t) && EQUAL(t) && LPAREN(t) && M(this,ident,&src_name) && RPAREN(t)) {
        M(&section->assign_.name_,set,M(&section->name_,c_str));
        M(&section->assign_,set_source_name,src_name.beg_,src_name.end_-src_name.beg_);
        if(YAOOC_PARSER_TRY_RULE(this,M(this,string_within_matching_chr,'{','}',&implementation))) {
          // If not top level file, can skip the implementation code
          M(&section->assign_,set_implementation,implementation.beg_,implementation.end_-implementation.beg_);
          return RULE_SUCCESS(this);
        } else if(EQUAL(t) && M(this,ident,&implementation) && SEMICOLON(t)) {
          // If not top level file, can skip the implementation code
          if(IS_DELETE(implementation)) {
            section->assign_.form_=DELETE;
          } else if(IS_DEFAULT(implementation)) {
            section->assign_.form_=DEFAULT;
          } else {
            M(&section->assign_,set_implemented_as,implementation.beg_,implementation.end_-implementation.beg_);
          }
          return RULE_SUCCESS(this);
        } else {
          printf("Error processing file %s at line number %d\n",yaoocpp_parser_file_being_parsed,this->line_no_);
          exit(1);
        }
      }
      return RULE_FAIL(this);
    }

    bool rich_compare(yaoocpp_struct_t* section)
    {
      yaooc_token_t t,lhs_name,rhs_name,implementation;
      RULE_START(this);
      if(M(this,str,"int",&t) && OPERATOR(t) && M(this,str,"<=>",&t) && LPAREN(t) &&
            M(this,ident,&lhs_name) && COMMA(t) && M(this,ident,&rhs_name) && RPAREN(t)) {
        M(&section->rich_compare_.name_,set,M(&section->name_,c_str));
        M(&section->rich_compare_,set_lhs_name,lhs_name.beg_,lhs_name.end_-lhs_name.beg_);
        M(&section->rich_compare_,set_rhs_name,rhs_name.beg_,rhs_name.end_-rhs_name.beg_);
        if(YAOOC_PARSER_TRY_RULE(this,M(this,string_within_matching_chr,'{','}',&implementation))) {
          // If not top level file, can skip the implementation code
          M(&section->rich_compare_,set_implementation,implementation.beg_,implementation.end_-implementation.beg_);
          return RULE_SUCCESS(this);
        } else if(EQUAL(t) && M(this,ident,&implementation) && SEMICOLON(t)) {
          if(IS_DELETE(implementation)) {
            section->rich_compare_.form_=DELETE;
          } else if(IS_DEFAULT(implementation)) {
            section->rich_compare_.form_=DEFAULT;
          } else {
            M(&section->rich_compare_,set_implemented_as,implementation.beg_,implementation.end_-implementation.beg_);
          }
          return RULE_SUCCESS(this);
        } else {
          printf("Error processing file %s at line number %d\n",yaoocpp_parser_file_being_parsed,this->line_no_);
          exit(1);
        }
      }
      return RULE_FAIL(this);
    }

    bool to_stream(yaoocpp_struct_t* section)
    {
      yaooc_token_t t,strm_name,implementation;
      RULE_START(this);
      if(M(this,str,"operator",&t) && M(this,str,"<<",&t) && LPAREN(t) && M(this,ident,&strm_name) && RPAREN(t)) {
        M(&section->to_stream_.name_,set,M(&section->name_,c_str));
//        M(&section->to_stream_.name_,append,"_to_stream");
        M(&section->to_stream_,set_stream_name,strm_name.beg_,strm_name.end_-strm_name.beg_);
        if(YAOOC_PARSER_TRY_RULE(this,M(this,string_within_matching_chr,'{','}',&implementation))) {
          // If not top level file, can skip the implementation code
          M(&section->to_stream_,set_implementation,implementation.beg_,implementation.end_-implementation.beg_);
          return RULE_SUCCESS(this);
        } else if(EQUAL(t) && M(this,ident,&implementation) && SEMICOLON(t)) {
//          M(&section->to_stream_,set_implemented_as,implementation.beg_,implementation.end_-implementation.beg_);
          return RULE_SUCCESS(this);
        } else {
          printf("Error processing file %s at line number %d\n",yaoocpp_parser_file_being_parsed,this->line_no_);
          exit(1);
        }
      }
      return RULE_FAIL(this);
    }

    bool from_stream(yaoocpp_struct_t* section)
    {
      yaooc_token_t t,strm_name,implementation;
      RULE_START(this);
      if(M(this,str,"operator",&t) && M(this,str,">>",&t) && LPAREN(t) && M(this,ident,&strm_name) && RPAREN(t)) {
        M(&section->from_stream_.name_,set,M(&section->name_,c_str));
//        M(&section->from_stream_.name_,append,"_from_stream");
        M(&section->from_stream_,set_stream_name,strm_name.beg_,strm_name.end_-strm_name.beg_);
        if(YAOOC_PARSER_TRY_RULE(this,M(this,string_within_matching_chr,'{','}',&implementation))) {
          // If not top level file, can skip the implementation code
          M(&section->from_stream_,set_implementation,implementation.beg_,implementation.end_-implementation.beg_);
          return RULE_SUCCESS(this);
        } else if(EQUAL(t) && M(this,ident,&implementation) && SEMICOLON(t)) {
//          M(&section->from_stream_,set_implemented_as,implementation.beg_,implementation.end_-implementation.beg_);
          return RULE_SUCCESS(this);
        } else {
          printf("Error processing file %s at line number %d\n",yaoocpp_parser_file_being_parsed,this->line_no_);
          exit(1);
        }
      }
      return RULE_FAIL(this);
    }

    bool include(yaoocpp_struct_t* section)
    {
      RULE_START(this);
      yaooc_token_t t,id;
      if(M(this,str,"include",&t)) {
#define mixin_vector &((yaoocpp_struct_pointer)section)->mixins_
        do {
          int saved_line_no=this->line_no_;
          if(M(this,ident,&id)) {
            yaooc_string_t temp=YAOOC_STRING_STATIC_DEFAULT_CTOR;
            M(&temp,setn,id.beg_,id.end_-id.beg_);
            if(yaooc_find(yaooc_string,M(mixin_vector,begin),M(mixin_vector,end),&temp) != M(mixin_vector,end))
            {
              printf("Duplicate mixin specified on or before line %d\n",saved_line_no);
              exit(30);
            }
            M(mixin_vector,push_back,&temp);
            deletep(&temp,yaooc_string);
          } else {
            printf("Error including mixins on or before line %d\n",saved_line_no);
            exit(31);
          }
        } while(COMMA(t));
        if(SEMICOLON(t)) {
          return RULE_SUCCESS(this);
        }
#undef mixin_vector
      }
      return RULE_FAIL(this);
    }

    bool va_argument(yaoocpp_argument_t** arg)
    {
      RULE_START(this);
      yaooc_token_t t;
      if(M(this,str,"...",&t)) {
        *arg=new(yaoocpp_argument);
        M(&(*arg)->type_,setn,t.beg_,t.end_-t.beg_);
        if(M(this,ident,&t)) {
          M(&(*arg)->name_,setn,t.beg_,t.end_-t.beg_);
        } else {
          M(&(*arg)->name_,set,"args");
        }
        return RULE_SUCCESS(this);
      }
      return RULE_FAIL(this);
    }

    bool argument(yaoocpp_argument_t** arg)
    {
      RULE_START(this);
      yaooc_token_t t;
      *arg = NULL;
      if(M(this,ident,&t)) {
        *arg = new(yaoocpp_argument);
        M(&(*arg)->type_,setn,t.beg_,t.end_-t.beg_);
        while(true) {
          if(M(this,ident,&t)) {
            if(M(&(*arg)->name_,size)>0) {
              M(&(*arg)->type_,append," ");
              M(&(*arg)->type_,append,M(&(*arg)->name_,c_str));
            }
            M(&(*arg)->name_,setn,t.beg_,t.end_-t.beg_);
          } else if(STAR(t)) {
            if(M(&(*arg)->name_,size)>0) {
              M(&(*arg)->type_,append," ");
              M(&(*arg)->type_,append,M(&(*arg)->name_,c_str));
              M(&(*arg)->name_,clear);
            }
            M(&(*arg)->type_,append,"*");
          } else
            break;
        }
        if(M(&(*arg)->name_,size) > 0) {
          // capture array declarations
          while(M(this,string_within_matching_chr,'[',']',&t)) {
            M(&(*arg)->array_def_,append,"[");
            M(&(*arg)->array_def_,appendn,t.beg_,t.end_-t.beg_);
            M(&(*arg)->array_def_,append,"]");
          }
          return M(&(*arg)->name_,size) > 0 ? RULE_SUCCESS(this) : RULE_FAIL(this);
        }
      }
      if(*arg != NULL)
        delete(*arg);
      return RULE_FAIL(this);
    }

    bool arguments(yaoocpp_item_pointer_vector_t* args)
    {
      yaooc_token_t t;
      bool ret=false;
      do {
        yaoocpp_argument_t* arg;
        if(yaoocpp_parser_argument(this,&arg)) {
          M(args,push_back,make_dynamic_pointer(arg));
          delete(arg);
        } else if(yaoocpp_parser_va_argument(this,&arg)) {
          M(args,push_back,make_dynamic_pointer(arg));
          delete(arg);
        } else
          break;
        ret=true; // found at least one argument
      } while(COMMA(t));
      return ret;
    }

    bool constructor(yaoocpp_struct_t* section)
    {
      gb_init();
      RULE_START(this);
      bool has_initializers=false;
      yaooc_token_t t,con_name,implementation;
      int saved_line_no=this->line_no_;
      if(M(this,ident,&con_name) && LPAREN(t)) {
        size_t l = yaooc_token_len(con_name);
        if(l > M(&section->name_,size) && strncmp(con_name.beg_,M(&section->name_,c_str),M(&section->name_,size))==0) {
          // We have a constructor
          yaoocpp_constructor_t* con=gb_new(yaoocpp_constructor);
          M(&con->name_,setn,con_name.beg_,l);
          if(yaooc_find(yaooc_dynamic_pointer,M(&section->constructors_,cbegin),M(&section->constructors_,cend),(pointer)&con)
                != M(&section->constructors_,cend)) {
            printf("Duplicate constructor %s specified on line number %d\n",M(&con->name_,c_str),saved_line_no);
            exit(12);
          }
          if(yaoocpp_parser_arguments(this,&con->arguments_)) {
            if(RPAREN(t)) {
              if(COLON(t)) {
                has_initializers=true;
                yaoocpp_parser_constructor_initializers(this,&con->initializers_);
              }
              if(M(this,string_within_matching_chr,'{','}',&implementation)) {
                M(con,set_implementation,implementation.beg_,implementation.end_-implementation.beg_);
              } else if (EQUAL(t) && M(this,ident,&implementation) && SEMICOLON(t)) {
                if(has_initializers) {
                  printf("Error processing constructor %.*s\n"
                         "Cannot specify construction initializers and implementation method.",
                         (int)(con_name.end_-con_name.beg_),con_name.beg_);
                  exit(1);
                }
                M(con,set_implemented_as,implementation.beg_,implementation.end_-implementation.beg_);
              } else {
                printf("Error processing imlementation for constructor %.*s\n",(int)l,con_name.beg_);
                exit(3);
              }
              M(&section->constructors_,push_back,make_dynamic_pointer(con));
//              delete(con);
              gb_exit();
              return RULE_SUCCESS(this);
            }
            printf("Error parsing constructor at line number %d\n",saved_line_no);
            exit(33);
          } else {
            /* Constructors, other than default constructor, must have at least 1 argument */
            printf("Constructors must have at least 1 argument.\n"
                  "Constructor %.*s has zero arguments.\n",(int)l,con_name.beg_);
            exit(22);
          }
        }
      }
      gb_exit();
      return RULE_FAIL(this);
    }

    bool mixin(yaoocpp_mixin_t** mixin)
    {
      RULE_START(this);
      yaooc_token_t t,mixin_name;
      if(MIXIN(t)) {
        M(this,ident,&mixin_name);
        *mixin = new(yaoocpp_mixin);
        (*mixin)->defined_in_top_level_file_=yaoocpp_parser_is_top_level;
        M(&(*mixin)->name_,setn,mixin_name.beg_,mixin_name.end_-mixin_name.beg_);
        if(LBRACE(t)) {
          while(true) {
            if(!yaoocpp_parser_default_constructor(this,(yaoocpp_struct_t*)*mixin,false))
              if(!yaoocpp_parser_destructor(this,(yaoocpp_struct_t*)*mixin))
                if(!yaoocpp_parser_copy_constructor(this,(yaoocpp_struct_t*)*mixin,false))
                  if(!yaoocpp_parser_assignment(this,(yaoocpp_struct_t*)*mixin))
                    break;
          }
          while(true) {
            if(TABLE(t)) {
              yaoocpp_parser_sub_section(this,&(*mixin)->table_,true);
            } else if(INSTANCE(t)) {
              yaoocpp_parser_sub_section(this,&(*mixin)->instance_,false);
            } else if(ADJUNCT(t)) {
              yaoocpp_parser_sub_section(this,&(*mixin)->adjunct_,true);
            } else if(PRIVATE(t)) {
              yaoocpp_parser_sub_section(this,&(*mixin)->private_,true);
            } else
              break;
          }
        }
        if(RBRACE(t) && SEMICOLON(t)) {
          return RULE_SUCCESS(this);
        }
        else {
          printf("Error processing %s near line number %d\n",yaoocpp_parser_file_being_parsed,this->line_no_);
          exit(7);
        }
      }
      return RULE_FAIL(this);
    }
%if 0
    bool add_mixins(yaoocpp_class_t* cls)
    {
      // Add mixins only if attributes are not already defined
      yaooc_string_vector_const_iterator imixin_name;
//      M(cout,printf,"%zu mixins defined\n",M(&this->mixins_,size));
//      yaoocpp_mixin_const_pointer mi=*(yaoocpp_mixin_const_pointer*)M(&this->mixins_,cbegin);
//      printf("Name of first mixin is X%sX\n",M(&mi->name_,c_str));
      yaoocpp_item_t* temp=new(yaoocpp_item);
      CFOR_EACH(imixin_name,&cls->mixins_) {
        assign_static(&temp->name_,imixin_name,yaooc_string);
//        printf("Trying to find %s\n",M(&temp->name_,c_str));
        yaoocpp_mixin_const_pointer* mixin=yaooc_find(yaooc_dynamic_pointer,M(&this->mixins_,cbegin),M(&this->mixins_,cend),(pointer)&temp);
        if(mixin == M(&this->mixins_,cend)) {
//          printf("Mixin \"%s\" not found.\n",M(imixin_name,c_str));
          exit(7);
        }
//        M(cls,merge_mixin_instance,*mixin);
//        M(cls,merge_mixin_table,*mixin);
      }
      delete(temp);
      return true;
    }
%endif
  private:
};

%class yaoocpp_parser_exception : yaooc_exception
{
  yaoocpp_parser_exception_ctor_v(const char* fmt,...) = yaooc_exception_ctor_v;
};
