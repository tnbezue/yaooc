<!DOCTYPE html>
<!--
  Copyright (C) 2016-2019  by Terry N Bezue

  This program is free software: you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation, either version 3 of the License, or
  (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program.  If not, see <https://www.gnu.org/licenses/>.
-->
<html>
<head>
<title>Placement New and Delete</title>
<meta name="generator" content="Bluefish 2.2.10" >
<meta name="copyright" content="">
<meta name="keywords" content="">
<meta name="description" content="">
<meta name="ROBOTS" content="NOINDEX, NOFOLLOW">
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta http-equiv="content-type" content="application/xhtml+xml; charset=UTF-8">
<meta http-equiv="content-style-type" content="text/css">
<meta http-equiv="expires" content="0">
<link href="yaooc.css" rel="stylesheet" type="text/css">
<script type="text/javascript" src="yaooc.js"></script>
</head>
<body>
<div id="wrapper">
<script>header();</script>
<script>menu();</script>
<div id="content" class="content">
<div style="overflow-y: scroll; height:900px">
<h2>Placement New and Delete</h2>

<p>
In the previous lesson, static objects were introduced.  This lesson will introduce placement new to initialize
static objects and a placement delete to destroy these objects.
Note that C++ does not provide a placement delete but can be simulated by directly calling the destructor (ptr->~T()).
</p>
<div class="divTable">
<div class="divTableBody">
<div class="divTableRow">
<div class="divTableHead">Purpose</div>
<div class="divTableHead">C++</div>
<div class="divTableHead">YAOOC</div>
</div>
<div class="divTableRow">
<div class="divTableCell">Initialize the single object at ptr of type T using default constructor</div>
<div class="divTableCell">new (ptr) T</div>
<div class="divTableCell">newp(ptr,T)</div>
</div>
<div class="divTableRow">
<div class="divTableCell">Initialize array of n objects at ptr of type T</div>
<div class="divTableCell">new (ptr) T[n]</div>
<div class="divTableCell">newp_array(ptr,T,n)</div>
</div>
<div class="divTableRow">
<div class="divTableCell">Initialize new object from existing dynamically allocated object (copy constructor)<br>
Use newp_copy_static (below) to initialize from static object
</div>
<div class="divTableCell">new (ptr) T(ref)</div>
<div class="divTableCell">newp_copy(dst_ptr,src_ptr)</div>
</div>
<div class="divTableRow">
<div class="divTableCell">Initialize new object from existing static object</div>
<div class="divTableCell">N/A</div>
<div class="divTableCell">newp_copy_static(dst_ptr,T,src_ptr)</div>
</div>
<div class="divTableRow">
<div class="divTableCell">Initialize n new objects from existing dynamically allocated object (copy constructor)</div>
<div class="divTableCell">N/A</div>
<div class="divTableCell">newp_array_copy(dst_ptr,src_ptr,n)</div>
</div>
<div class="divTableRow">
<div class="divTableCell">Initialize n new objects from existing static object (copy constructor)</div>
<div class="divTableCell">N/A</div>
<div class="divTableCell">newp_array_copy_static(dst_ptr,T,src_ptr,n)</div>
</div>
<div class="divTableRow">
<div class="divTableCell">Initialize new object using specified constructor to initialize the object</div>
<div class="divTableCell">new (ptr) T(args)</div>
<div class="divTableCell">newp_ctor(ptr,T,ctor,args)</div>
</div>
<div class="divTableRow">
<div class="divTableCell">Initialize n new objects using specified constructor to initialize each object</div>
<div class="divTableCell">N/A</div>
<div class="divTableCell">newp_array_ctor(ptr,T,n,ctor,args)</div>
</div>
<div class="divTableRow">
<div class="divTableCell">Destroy single object of type T</div>
<div class="divTableCell">N/A</div>
<div class="divTableCell">deletep(ptr,T)</div>
</div>
<div class="divTableRow">
<div class="divTableCell">Destroy array of N objects of type T</div>
<div class="divTableCell">N/A</div>
<div class="divTableCell">deletep_array(ptr,T,N)</div>
</div>

</div>
</div>

<p>
Placement new can be used to initialize objects declared on the stack and deletep can be used to destroy these objects. For example:
</p>
<pre><code>
  my_string_t mys1;  /* Note that the &quot;_t&quot; is used */
  newp(&mys1,my_string);
  my_string_t mys2;
  newp_ctor(&mys2,my_string,my_string_ctor_ccs,&quot;This is a test&quot;);
  assign_static(&mys1,&mys2,my_string);
  M(&mys2,set,&quot;Changed value for mys2&quot;);
  deletep(&mys1,my_string);
  deletep(&mys2,my_string);
</code></pre>
<h3>Static object in streams</h3>
<p>
Streams use dynamically allocated objects.  As mentioned in the memory layout lesson, the type info for dynamically allocated objects is readily
available.  This information is used by the stream method.  For POD and static objects, the type info has to be added to the stream.
The macros below facilitate streams reading POD and static objects properly.
</p>


<div class="divTable">
<div class="divTableBody">
<div class="divTableRow">
<div class="divTableHead">Macro</div>
<div class="divTableHead">Description</div>
</div>
<div class="divTableRow">
<div class="divTableCell">I_OBJ(T,O)</div>
<div class="divTableCell">Input static object O of type T</div>
</div>
<div class="divTableRow">
<div class="divTableCell">I_CHR(ch)</div>
<div class="divTableCell">Input single character</div>
</div>
<div class="divTableRow">
<div class="divTableCell">I_UCHR(uch)</div>
<div class="divTableCell">Input single unsigned character</div>
</div>
<div class="divTableRow">
<div class="divTableCell">I_SHORT(s)</div>
<div class="divTableCell">Input short</div>
</div>
<div class="divTableRow">
<div class="divTableCell">I_USHORT(us)</div>
<div class="divTableCell">Input unsigned short</div>
</div>
<div class="divTableRow">
<div class="divTableCell">I_INT(i)</div>
<div class="divTableCell">Input integer</div>
</div>
<div class="divTableRow">
<div class="divTableCell">I_UINT(ui)</div>
<div class="divTableCell">Input unsigned integer</div>
</div>
<div class="divTableRow">
<div class="divTableCell">I_LONG(l)</div>
<div class="divTableCell">Input long</div>
</div>
<div class="divTableRow">
<div class="divTableCell">I_ULONG(ul)</div>
<div class="divTableCell">Input unsigned long</div>
</div>
<div class="divTableRow">
<div class="divTableCell">I_DBL(d)</div>
<div class="divTableCell">Input double</div>
</div>
<div class="divTableRow">
<div class="divTableCell">I_CCS(ccs)</div>
<div class="divTableCell">Input character string</div>
</div>
</div>
</div>

<p>
For writing POD and static objects to streams, use &quot;O_&quot; rather than &quot;I_&quot; for macros in above table.
</p>

<pre><code>
  my_string_t ms;
  newp(&ms,my_string);
  STREAM(cout,O_CCS(&quot;Enter a string value&quot),endl);
  STREAM(cin,I_OBJ(my_string,ms));
  STREAM(cout,O_CSS(&quot;The value enter was: &quot),O_OBJ(my_string,ms),endl);
</code></pre>
<h3>Important Note</h3>
<p>
You may have noticed that in the my_string_set method, the my_string_dtor method was called directly.
While calling the destructor in this case has no adverse affects, in other situations it may have unexpected results.
For example, if a class has 5 levels of inheritance (that is, child, parent, grand parent, great grand parent, great great grand parent),
then calling the destructor method directly only destroys the portion created by child.  It does not destory the parts created
by ancestors. It may be desirable to use deletep followed by newp.  The my_string_set method could be written as:
</p>

<pre><code>
  void my_string_set(pointer p,const char* s)
  {
    my_string_pointer this=p;
    deletep(this,my_string);  // Calls this destructor and ancestor destructors -- memory pointer to by this is not freed
    newp(this,my_string);     // Initializes object (however, it is ok to just call the default constructor directly)
    if(s)
      this->str = strdup(s);
  }
</code></pre>
<p>
Although the destructor should not be called directly, the default constructor, copy constructor, and assign method can be called
directly using the method name.  This is because the constructors and assign method must call any ancestor methods required to
initialize/assign the object.  The destructor is only required to destroy the portion that was created by the child.
</p>

</div>
</div>
</div>
</body>
</html>
