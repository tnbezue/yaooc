<!DOCTYPE html>
<!--
  Copyright (C) 2016-2019  by Terry N Bezue

  This program is free software: you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation, either version 3 of the License, or
  (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program.  If not, see <https://www.gnu.org/licenses/>.
-->
<html>
<head>
<title>Memory Layout</title>
<meta name="generator" content="Bluefish 2.2.10" >
<meta name="copyright" content="">
<meta name="keywords" content="">
<meta name="description" content="">
<meta name="ROBOTS" content="NOINDEX, NOFOLLOW">
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta http-equiv="content-type" content="application/xhtml+xml; charset=UTF-8">
<meta http-equiv="content-style-type" content="text/css">
<meta http-equiv="expires" content="0">
<link href="yaooc.css" rel="stylesheet" type="text/css">
<script type="text/javascript" src="yaooc.js"></script>
</head>
<body>
<div id="wrapper">
<script>header();</script>
<script>menu();</script>
<div id="content" class="content">
<div style="overflow-y: scroll; height:900px">
<h2>Memory Layout</h2>
<p>
Before continuing with the my_string class, it's helpful to understand how memory allocation is handled in YAOOC.
When an object (or array of objects) is allocated, additional memory is allocated for a pointer to type info structure and the number of
objects allocated.  This memory layout is shown below.
</p>
<div class="divTable">
<div class="divTableBody">
<div class="divTableRow">
<div class="divTableCell">Pointer to type info structure (const type_info_t*)</div>
</div>
<div class="divTableRow">
<div class="divTableCell">Number of elements allocated (size_t)</div>
</div>
<div class="divTableRow">
<div class="divTableHead">1st element (new returns pointer to this element)</div>
</div>
<div class="divTableRow">
<div class="divTableCell">2nd element</div>
</div>
<div class="divTableRow">
<div class="divTableCell">...</div>
</div>
<div class="divTableRow">
<div class="divTableCell">nth element</div>
</div>
</div>
</div>

<p>
The overhead is 8 bytes for a 32 bit system and 16 bytes for a 64 bit system.  Note that this is per allocation -- not per element.
If a single character is allocated, 9 (or 17) bytes will actually be allocated.  An array of 100,000 characters would require 100,008 (or 100,016) bytes.
</p>
<p>
This memory allocation scheme allows the type info to be readily available for internal YAOOC methods that uses it. For example, the assign method
can access the type info to apply the appropriate assignment method.  Likewise, the delete method can determine the destructor and number
of elements to delete. User methods should not try to access the type info or element count.
</p>
<p>
For variables declared on the stack or for elements beyond the first element of an array (henceforth, will be referred to as static objects),
the type info structure is not available.
Therefore, some of the methods that have been presented so far will not work on static objects.  Static versions of these methods (appended with "_static") will have to be used.
Since the type info pointer is not available, the class type is included as an argument to the static versions.
</p>
<p>
Static versions of assign and comparison methods are presented below.
</p>

<div class="divTable">
<div class="divTableBody">
<div class="divTableRow">
<div class="divTableHead">Method</div>
<div class="divTableHead">Purpose</div>
</div>
<div class="divTableRow">
<div class="divTableCell">assign_static(p1,p2,T)</div>
<div class="divTableCell">Assign object p2 to object p1. Both are of type T</div>
</div>
<div class="divTableRow">
<div class="divTableCell">op_eq_static(p1,p2,T)</div>
<div class="divTableCell">Compares if objects p1 and p2 of type T are equal</div>
</div>
<div class="divTableRow">
<div class="divTableCell">op_ne_static(p1,p2,T)</div>
<div class="divTableCell">Compares if objects p1 and p2 of type T are not equal</div>
</div>
<div class="divTableRow">
<div class="divTableCell">op_lt_static(p1,p2,T)</div>
<div class="divTableCell">Compares if object p1 is less than p2.  Both objects are of type T</div>
</div>
<div class="divTableRow">
<div class="divTableCell">op_le_static(p1,p2,T)</div>
<div class="divTableCell">Compares if object p1 is less than or equal to p2.  Both objects are of type T</div>
</div>
<div class="divTableRow">
<div class="divTableCell">op_gt_static(p1,p2,T)</div>
<div class="divTableCell">Compares if object p1 is greater than p2.  Both objects are of type T</div>
</div>
<div class="divTableRow">
<div class="divTableCell">op_ge_static(p1,p2,T)</div>
<div class="divTableCell">Compares if object p1 is greater than or equal to p2.  Both objects are of type T</div>
</div>
</div>
</div>

<p>
For example, to compare if two static my_string objects are equal, use:
</p>
<pre><code>
  #define INIT_STATIC_MY_STRING { .class_table_=&amp;my_string_class_table, .str=NULL }
  my_string_t ms1 = INIT_STATIC_MY_STRING;
  my_string_t ms2 = INIT_STATIC_MY_STRING;
  ....
  if(op_eq_static(&amp;ms1,&amp;ms2,my_string))
    puts("Equal");
</code></pre>
<p>
<p>

</p>
In C, when a YAOOC object is declared on the stack (static), the default constructor is not called to initialize the object.
The above example shows how a static object may be initialized. This can be cumbersome for a class with many instance members.
A more practical method will be presented in the next lesson.
</p>
<h3>Renew</h3>
<p>
While on the subject of memory, it should be noted that YAOOC provides a method that is not available in C++ -- renew. Renew is to new as realloc is to malloc. ptr is a pointer to memory that was
previously allocated with new (unlike realloc, it cannot be NULL). The following table shows the forms of renew.
</p>
<div class="divTable">
<div class="divTableBody">
<div class="divTableRow">
<div class="divTableHead">Method</div>
<div class="divTableHead">Description</div>
</div>
<div class="divTableRow">
<div class="divTableCell">renew_array(ptr,N)</div>
<div class="divTableCell">Reallocates memory at ptr for N elements by appending elements created using the default constructor</div>
</div>
<div class="divTableRow">
<div class="divTableCell">renew_array_copy(ptr,N,src);</div>
<div class="divTableCell">Reallocates memory at ptr for N elements. Appended elements are a copy of src object</div>
</div>
<div class="divTableRow">
<div class="divTableCell">renew_array_ctor(ptr,N,ctor,args);</div>
<div class="divTableCell">Reallocates memory at ptr for N elements. Appended elements are constructed using ctor</div>
</div>
</div>
</div>

<p>
The above table only presents the case where N is greater than the current allocation.  If N is less than the current allocation,
the destructor is called for each element removed before memory is reallocated.  If N is the same as the current allocation, no action is taken.
</p>

<pre><code>
  my_string_t* demo=new_array(my_string,8); /* Initial size is 8 */
  ...
  demo=renew(demo,20); /* Increase capacity to 20 */
  ...
  demo=renew(demo,5); /* Decrease capacity to 5 */
</code></pre>

</div>
</div>
</div>
</body>
</html>
