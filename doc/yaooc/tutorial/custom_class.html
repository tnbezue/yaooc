<!DOCTYPE html>
<!--
  Copyright (C) 2016-2019  by Terry N Bezue

  This program is free software: you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation, either version 3 of the License, or
  (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program.  If not, see <https://www.gnu.org/licenses/>.
-->
<html>
<head>
<title>Custom Class</title>
<meta name="generator" content="Bluefish 2.2.10" >
<meta name="copyright" content="">
<meta name="keywords" content="">
<meta name="description" content="">
<meta name="ROBOTS" content="NOINDEX, NOFOLLOW">
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta http-equiv="content-type" content="application/xhtml+xml; charset=UTF-8">
<meta http-equiv="content-style-type" content="text/css">
<meta http-equiv="expires" content="0">
<link href="yaooc.css" rel="stylesheet" type="text/css">
<script type="text/javascript" src="yaooc.js"></script>
</head>
<body>
<div id="wrapper">
<script>header();</script>
<script>menu();</script>
<div id="content" class="content">
<div style="overflow-y: scroll; height:900px">
<h2>Custom Class</h2>
<p>
Over the next few lessons a custom class will be created.  The class will be a simple string class.
This is meant to show the features of YAOOC rather than good programming practice.
</p>
<p>
The simplest class can be defined as follows:
</p>
<pre><code>
  #include <yaooc/new.h>
  #include <stdio.h>

  %struct my_string {
    instance:
      char* str;
  };

  int main(int argc,char* argv[])
  {
    my_string_t* ms = new(my_string);
    ms->str=strdup("This is a test of my_string");
    /* Do some other stuff with my_string */
    free(my->str);
    delete(ms);
  }
</code></pre>
<p>
"%struct" specifies the beginning of the class definition. Variable declared following "instance:" will be members
of the object.
</p>
<p>
Of cource the C compiler cannot directly compile the above.  The YAOOCPP preprocessor (yaoocpp) is used to translate
the above into a C header and source file. The will b
</p>
<pre><code>
  yaoocpp my_string.yoc
  gcc -I/usr/local/include -o my_string my_string.c -Wall
</code></pre>
<p>
Let's make my_string a bit more robust by adding default constructor, destructor, copy_constructor, and assignment (operator= in C++).
</p>
<pre><code>
  #include <yaooc/new.h>
  #include <stdio.h>
  %struct my_string {
      // Default constructor -- method name will be my_string_default_ctor
      my_string()
      {
        // "this" is a my_string pointer to this instance of my_string
        // It is automatically added as first argument.
        this->str=NULL;
      }
      // Destructor  -- method name will be my_string_dtor
      ~my_string()
      {
        if(this->str)
          free(this->str);
      }
      // Assignment  -- method name will be my_string_assign
      // src is a const pointer to another my_string instance
      operator=(src)
      {
        my_string_dtor(this);  // can call destructor directly.  Note that "this" has to be included as first argument
        this->str = src->str ? strdup(src->str) : NULL;
      }
      // Copy constructor -- method name will be my_string_copy_ctor
      my_string(src) : my_string()  // default constructor used as initializer
      {
        my_string_assign(this,src);
      }
      // Used for compareing my_string object
      // Returns &lt;0 for lhs&ltrhs; 0 if lhs=rhs; &gt;0 if lhs&gt;rhs
      int operator<=>(lhs,rhs)
      {
        // lhs and rhs are const pointers to my_string instances
        if(lhs->str == NULL) {
          if(rhs->str == NULL)
            return 0; /* both NULL, equal */
          else
            return -1; /* lhs is NULL, rhs is not.  NULL is less than not NULL */
        } else if(rhs->str == NULL)
          return 1; /* lhs is not NULL, rhs is NULL. non NULL greater than NULL */
        return strcmp(lhs->str,rhs->str); /* Both not null, compare the strings */
      }
    instance:
      char* str;
  };

  int main(int argc,char* argv[])
  {
    my_string_t* ms1 = new(my_string);
    ms1->str=strdup("This is a test of my_string");
    my_string_t* ms2 = new_copy(ms1);  // Create ms2 by copying ms1
    /* Do some other stuff with my_string objects*/
    my_string_t* ms3 = new(my_string);
    assign(ms3,ms2);  // Assignment, in C++ ms3=ms2
    /* Do some more stuff with my_string objects*/
    if(op_lt(ms3,ms2))
      print("'%s' is less than '%s'",ms3->str,ms2->str);
    delete(ms1);
    delete(ms2);
    delete(ms3);
  }
</code></pre>
<p>
Note that the constructor, destructor, copy constructor, and assignment must appear before "instance:".
</p>
<h3>Important Requirement</h3>
<p>
Before continuing with the my_string class, one important requirement for custom classes -- class instances must be movable.  For example:
</p>
<pre><code>
  %struct circular_buffer {
    char* beg;
    char* end;
    char buffer[32];
  };
</code></pre>
<p>
In the above example, if beg and end are pointers to locations within buffer, then the pointers would be invalidated if the object is
moved to a different memory location. Thus it is an immovable object and should not be used in YAOOC.
</p>
<p>
If the class was defined as:
</p>
<pre><code>
  %struct circular_buffer {
    char* beg;
    char* end;
    char* buffer;
  };
</code></pre>
<p>
If beg and end are pointers to memory within memory pointed to by buffer, then moving the object will not invalidate the pointers.
This it a movable object and can be used in YAOOC.
</p>
</div>
</div>
</div>
</body>
</html>
