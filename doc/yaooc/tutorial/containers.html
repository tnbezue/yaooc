<!DOCTYPE html>
<!--
  Copyright (C) 2016-2019  by Terry N Bezue

  This program is free software: you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation, either version 3 of the License, or
  (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program.  If not, see <https://www.gnu.org/licenses/>.
-->
<html>
<head>
<title>Yaooc PreProcessor</title>
<meta name="generator" content="Bluefish 2.2.10" >
<meta name="copyright" content="">
<meta name="keywords" content="">
<meta name="description" content="">
<meta name="ROBOTS" content="NOINDEX, NOFOLLOW">
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta http-equiv="content-type" content="application/xhtml+xml; charset=UTF-8">
<meta http-equiv="content-style-type" content="text/css">
<meta http-equiv="expires" content="0">
<link href="yaooc.css" rel="stylesheet" type="text/css">
<script type="text/javascript" src="yaooc.js"></script>
</head>
<body>
<div id="wrapper">
<script>header();</script>
<script>menu();</script>
<div id="content" class="content">
<div style="overflow-y: scroll; height:900px">
<h2>Containers</h2>
<p>
Another feature of C++ that is implemented in YAOOC is containers -- vector, map, set, etc. One goal of YAOOC is to use similar
iterators as C++ (increment and decrement using ++ or --).  The only structure in C that allows this is an array.  Therefore,
the base class for vector, map, set, etc is an array.  The table below shows the array types that are implemented in YAOOC.
</p>


<div class="divTable">
<div class="divTableBody">
<div class="divTableRow">
<div class="divTableHead">Array type</div>
<div class="divTableHead">Description</div>
</div>
<div class="divTableRow">
<div class="divTableCell">array_container</div>
<div class="divTableCell">Random access array container</div>
</div>
<div class="divTableRow">
<div class="divTableCell">unique_array_container</div>
<div class="divTableCell">Random access array container where values are unique</div>
</div>
<div class="divTableRow">
<div class="divTableCell">ordered_array_container</div>
<div class="divTableCell">Ordered random array access container</div>
</div>
<div class="divTableRow">
<div class="divTableCell">unique_ordered_array_container</div>
<div class="divTableCell">Ordered random array access container where values are unique</div>
</div>
<div class="divTableRow">
<div class="divTableCell">index_array_container</div>
<div class="divTableCell">Random access array container with shadow index such that array[index[i]] (i=0 to n) will be ordered</div>
</div>
<div class="divTableRow">
<div class="divTableCell">unique_index_array_container</div>
<div class="divTableCell">Random access indexed array container where values are unique</div>
</div>
<div class="divTableRow">
<div class="divTableCell">rbtree_index_array_container</div>
<div class="divTableCell">Random access array container with indexes kept in a red black tree.  array[node->index] (node is rb tree iterator) is ordered</div>
</div>
</div>
</div>

<p>
These containers are used to implement higher level containers such as vector or map.
Items that are contained in the array should have the less than compare type info method defined.
The storage of the container is handled automatically, being expanded and contracted as needed.
Any iterators for an array may be invalidated when an item is inserted.
</p>

<p>
The array_container is good for storing items that are appended to the end.  As the size increases, search time increases since
the search is sequential.
</p>
<p>
The unique_array_container is the same as array_container except items are unique.  As with array_container, as size
increases, so does search time.  Insert time also increases since array must be searched before insert.
</p>
<p>
The ordered_array_container keeps items in an ordered fashion.  Since items are ordered, search times are decreased.  Insert
times may increase if items are not entered in order.
</p>
<p>
The unique_ordered_array_container keeps items in an ordered fashion and eliminates duplicate items.
</p>
<p>
The index_array_container maintains a shadow index array such that array[index[i]] (i = 0 to size-1) will be ordered.  This
allows items to be added to end of main array with inserts occurring in  the index array. This allows for faster inserts (since items are added to end)
and faster searches (because of shadow index).
</p>
<p>
The unique_index_array_container is the same as index_array_container except values are unique.
</p>
<p>
The rbtree_index_array_container behaves the same as the unique_index_array_container.  However, indexes are kept
in a red black tree.  The rbtree_index_array_container is about 20 times faster than unique_index_array_container.
</p>
<h3>Methods</h3>
<p>The following methods are defined by array.</p>

<div class="divTable">
<div class="divTableBody">
<div class="divTableRow">
<div class="divTableHead">method</div>
<div class="divTableHead">Description</div>
</div>
<div class="divTableRow">
<div class="divTableCell">size_t size() const</div>
<div class="divTableCell">Current size of array</div>
</div>
<div class="divTableRow">
<div class="divTableCell">size_t capacity() const</div>
<div class="divTableCell">Current capacity of array</div>
</div>
<div class="divTableRow">
<div class="divTableCell">bool empty() const</div>
<div class="divTableCell">True if size is 0</div>
</div>
<div class="divTableRow">
<div class="divTableCell">iterator begin()</div>
<div class="divTableCell">iterator to beginning of array</div>
</div>
<div class="divTableRow">
<div class="divTableCell">iterator end()</div>
<div class="divTableCell">iterator to end of array</div>
</div>
<div class="divTableRow">
<div class="divTableCell">const_iterator cbegin() const</div>
<div class="divTableCell">const iterator to beginning of array</div>
</div>
<div class="divTableRow">
<div class="divTableCell">const iterator cend() const</div>
<div class="divTableCell">const iterator to end of array</div>
</div>

</div>
</div>

<p>
Values are inserted into containers using pointers to values (not the value).
For example, if int_vec is an integer vector, the following is most likely not what was intended.
</p>
<pre><code>
  M(int_vec,insert,M(int_vec,cend),20);  // Invalid insertion of 20 at end of vector
</code></pre>
<p>
To insert a value into a container, assign the values to a instance of the correct type,
and pass the address of the variable as the value to be inserted.
</p>
<pre><code>
  int value=20;
  M(int_vec,insert,M(int_vec,cend),&amp;value);  // Correctly inserts 20 at end of vector
</code></pre>

<h3>Iterators</h3>
An iterator and const_iterator is available for derived classes.  Caution should be used when using methods that return an iterator.
In the example below, if array is an integer array, the iterators i and j are not equal.
<pre><code>
  iterator i = M(array,begin)+5;
  iterator j = M(array,at,5);
</code></pre>
<p>
Since begin returns a generic iterator (void * -- which many compilers treat as char* in mathematical operations),
begin + 5 would be just 5 bytes beyond beginning of array -- which is most likely not what was intended.
The at method will return 5*sizeof(int) bytes beyond beginning of array -- which is probably what was intended.
</p>
<p>
However, the following could be used:
</p>
<pre><code>
   typedef int * integer_array_iterator;
   integer_array_iterator i = M(array,begin);
   i += 5;
</code></pre>
</div>
</div>
</div>
</body>
</html>
