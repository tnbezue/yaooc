<!DOCTYPE html>
<html>
<head>
<title>YAOOCPP</title>
<meta name="generator" content="Bluefish 2.2.10" >
<meta name="copyright" content="">
<meta name="keywords" content="">
<meta name="description" content="">
<meta name="ROBOTS" content="NOINDEX, NOFOLLOW">
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta http-equiv="content-type" content="application/xhtml+xml; charset=UTF-8">
<meta http-equiv="content-style-type" content="text/css">
<meta http-equiv="expires" content="0">
<link href="yaooc.css" rel="stylesheet" type="text/css">
<script type="text/javascript" src="yaooc.js"></script>
</head>
<body>
<div id="wrapper">
<script>header();</script>
<script>menu();</script>
<div id="content" class="content">
<div style="overflow-y: scroll; height:850px">
<h2><center>YAOOCPP</center></h2>
<p>
With multiple levels of inheritance and increasing number of methods, you will find that maintaining the class table
increasingly tedious.  The YAOOC PreProcessor (YAOOCPP) alleviates this tedious work -- and more.
</p>
<p>
Input to the YAOOC PreProcessor is a YAOOC class definition. YAOOC will generate the header and C source file for the class.
</p>
<p>
The header will contain:
</p>
<ul>
<li> the class_table, class_instance, and class definitions for the class.</li>
<li> prototypes for constructors, non private class methods, and variables.</li>
</ul>
<p>
C source file will contain:
</p>
<ul>
<li> templates for constructors and class methods</li>
<li> complete variable definition</li>
<li> class table for the class will be completely defined</li>
<li> the DEFINE_TYPE_INFO specification</li>
</ul>
<p>
The YAOOC class definition is shown below.
</p>
<pre><code>
  #include &lt;parent.yaooc&gt;
  class class_name : parent 
  {
      &lt;Type Info&gt;
      &lt;Constructors&gt;
    table:
      &lt;Table methods and variables&gt;
    instance:
      &lt;Instance methods and variables&gt;
    protected:
      &lt;Protected methods and variables&gt;
    private:
      &lt;Private methods and variables&gt;
  };
</code></pre>
<h3>Class Definition and inheritance</h3>
<p>
The include directive is used to include the class definition of the parent class.  There can be multiple include files specified.
</p>
<p>
class_name is the name of the new class (the "_t" should not be included).  parent is the parent class name.
</p>
<h3>Type Info</h3>
<p>
There are seven possible entries in the type info section which correspond to entries in the type info table.
Any or all of the entries may be omitted.  NULL will be used for entries that do not appear.
Those entries are shown below. 
</p>
<pre>
<code>
  class_name();    /* Generate template for default constructor */
  ~class_name();   /* Generate template for destructor */
  class_name(class_name);  /* Generate template for copy constructor */
  operator=();   /* Generate template for assignment method */
  operator&lt;();   /* Generate template for less than compare method */
  operator&lt;&lt;(); /* Generate template for to_stream method */
  operator&gt;&gt;(); /* Generate template for from_stream method */
</code>
</pre>
<p>
The entries can be specified in any order.
</p>
<h3>Constructors</h3>
<p>
The constructors section identifies the constructors that will be available for this class.
</p>
<ul>
<li>Constructors should begin with the class_name and followed by "_ctor_" and
one or more valid identifier characters. 
</li>
<li>
Pointer to object to initialize is automatically added as first argument.   
</li>
</ul>
<p>
Items for type info and constructors can be intermixed.  That is, definition order could be default constructor,
addition constructors, then remaining type info entries.  Or any other order.  However, the type info and constructor
section must be the first section of the class definition.
</p>
<h3>Table</h3>
<p>
Class table entries are defined in the table section.  The syntax for variable members is:
</p>
<pre><code>
  var_type var_name [ = value ];
</code></pre>
<p>
For the table section, the value is almost always specified.  If value is a string, it should be
enclosed in double quotes. If value is not specified, 0 (zero) is assumed.
</p>
<p>The syntax for method definition is:</p>
<pre><code>
  ret_type method(arg1_type arg1,arg2_type arg2,...,argn_type argn) [const] [ = implementation_method ];
</code></pre>
<ul>
<li>
Table methods from parent are inherited.  Only new or overridden methods need to be specified.
</li>
<li>
If a method is overridden, it should have the same signature (return type, name, and arguments) as the parent method.
</li>
<li>
It is implied that the first argument of the method is a pointer to object.  Thus it should not be specified.  
</li>
<li>
Arguments must specify type and name. Variadic argument (...) can be specified as last argument.
</li>
<li>
Specifying const will cause const_pointer to be used as first argument rather than pointer.
</li>
<li>
Implementation_method is the name of an existing method.  If specified, a template for the method is not generated and
the implementation method will be specified in the class table. 
</li>
</ul>

<h3>Instance</h3>
<p>
Items in instance section follow the same rules as the table section -- with a few exceptions.
</p>
<ul>
<li>
Only new items can be added to instance -- methods can not be overridden. 
</li>
<li>
Values and implementation methods are ignored for instance members.
</li>
</ul>
<h3>Protected</h3>
<p>
Protected does not have the same meaning as in C++.  Protected members are defined in the header file and implemented in C source file.
They are meant to be helpers to class and derived classes.
</p>
<h3>Private</h3>
<p>
Private members are defined as static in the C source file.  Can only be used by the class being created.
</p>
<p>
Since YAOOCPP does much of the tedious work, a more robust string class can be created.  This example is meant to show features
of YAOOCPP rather than good programming practice.
</p>
<pre><code>
  #ifndef __MY_STRING_YAOOC_INCLUDED__
  #define __MY_STRING_YAOOC_INCLUDED__
  #include "object.yaooc"

  class my_string : yaooc_object
  {
      my_string();                                                   /* default constructor. */
      my_string_ctor_ccs_n(const char* s,size_t n);                  /* Constructor 1 */
      my_string_ctor_ccs(const char* s);                             /* Constructor 2 */
      my_string_ctor_chr_n(int ch,size_t n);                         /* Constructor 3 */
      ~my_string();                                                  /* destructor */
      my_string(my_string);                                          /* copy constructor */
      operator=();                                                   /* assignment */
      operator&lt;();                                                   /* less than compare */
      operator&lt;&lt;();                                                  /* to stream */
      operator&gt;&gt;();                                                  /* from stream */
    
  
    table:
      const size_t my_string_n_pos = -1;                             /* variable in class table. */
      const char* isa() const;                                       /* Override yaooc_object isa method */
      void swap(pointer o);                                          /* Override yaooc_object swap method */
      const char* get() const;                                       /* returns string value */
      const char* c_str() const = my_string_get;                     /* same as get */
      void set(const char* s);                                       /* Sets string */
      my_string_pointer substr(size_t beg,size_t n);                 /* Return new string object created from substring of this string */
      void insert(size_t pos,const char* s);                         /* Insert string at position */
      void insertn(size_t pos,const char* s,size_t n);               /* Insert n chars from string at position */
      void erase(size_t pos,size_t n);                               /* Erase n chars starting at pos */
      void append(const char* s);                                    /* Append string */
      void appendn(const char* s,size_t n);                          /* Append n characters from string */
      const char* find(const char* s) const;                         /* return pointer to first occurance of substring s in this string */
      const char* rfind(const char* s) const;                        /* return pointer to last occurance of substring s in this string */
      const char* find_chr(char ch) const;                           /* return pointer to last occurance of character ch in this string */
      const char* rfind_chr(char ch) const;                          /* return pointer to last occurance of character ch in this string */
      char * at(size_t i);                                           /* Return pointer to character at index i */
      size_t size() const;                                           /* Return size of string */
      size_t length() const = my_string_size;                        /* Same as size */
      char* begin() const = my_string_get;                           /* Return beginning of string. Same as get */
      char* end() const;                                             /* Returns end of string */
    instance:
      char * str;                                                    /* The string */
    
    private:
      size_t allocate_space(size_t n);                               /* Allocates space to hold string */
    protected:
      void insert_space(size_t pos,size_t n);                        /* Insert space in string */
      void erase_space(size_t pos,size_t n);                         /* erase space in string */
  };
  #endif
</code></pre>
<p>
Multiple class definitions can appear in a file.  Table, instance, protected, and private section can be in any order.  There can also be multiple sections
of same type.  That is, there can be multiple table and/or instance sections.  Any section can be omitted. C and C++ style comments can be used.
</p>
<h3>Executing YAOOCPP</h3>
The syntax for executing yaoocpp is similar to executing the C preprocessor.  In fact, yaoocpp uses the C preprocessor so many preprocessor directives
(#ifdef, etc) can be used in the class definition file.
<pre><code>
Syntax: yaoocpp [ -h | --help ]
        yaoocpp [ -v | --version ]
        yaoocpp [ -I | --include <path> ] [ -Dmacro<=value> ] file.yaooc
Where:
  -h|--help -- prints this help
  -v|--version -- prints version information
  -I|--include -- Include path for C preprocessor
  -D|--define  -- Define macro
  file.yaooc -- preprocesses file.yaooc into file.h.template and file.c.template
</code></pre>
<p>
For my_string class, use:
</p>
<pre><code>
  yaooc -I`yaooc-config --prefix`/share/yaooc/templates my_string.yaooc
</code></pre>
<p>
Examine the contents of my_string.h.template and my_string.c.template to understand the output of yaoocpp.  Compare to my_string.h
and my_string.c to see how much code was added.
</p>
</div>
</div>
</div>
</body>
</html>